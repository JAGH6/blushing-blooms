<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #1a1a2e;
      color: #eee;
      font-family: system-ui, sans-serif;
    }
    h1 { margin: 0 0 0.5rem 0; font-size: 1.5rem; }
    #score { margin-bottom: 0.5rem; font-size: 1.25rem; }
    #game-over {
      display: none;
      position: absolute;
      background: rgba(0,0,0,0.85);
      padding: 1.5rem 2rem;
      border-radius: 8px;
      text-align: center;
      z-index: 10;
    }
    #game-over.show { display: block; }
    #game-over p { margin: 0 0 1rem 0; font-size: 1.25rem; }
    #restart {
      padding: 0.5rem 1.25rem;
      font-size: 1rem;
      cursor: pointer;
      background: #4a9;
      border: none;
      border-radius: 4px;
      color: #fff;
    }
    #restart:hover { background: #5ba; }
    .wrap { position: relative; }
    canvas {
      display: block;
      background: #0f0f1a;
      border: 2px solid #333;
    }
  </style>
</head>
<body>
  <h1>Tetris</h1>
  <div id="score">Score: 0</div>
  <div class="wrap">
    <canvas id="canvas" width="240" height="480"></canvas>
    <div id="game-over">
      <p>Game Over</p>
      <button id="restart">Restart</button>
    </div>
  </div>

  <script>
    // --- Constants ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 24;
    const SPAWN_X = 3;
    const SPAWN_Y = 0;
    const DROP_MS = 900;
    const SCORE_PER_LINE = [0, 100, 300, 500, 800];

    const COLORS = [
      null,
      '#00f0f0', // I cyan
      '#f0f000', // O yellow
      '#a000f0', // T purple
      '#00f000', // S green
      '#f00000', // Z red
      '#0000f0', // J blue
      '#f0a000', // L orange
    ];

    // --- Shape data: 7 tetrominoes, 4 rotations each (4x4 matrix) ---
    const SHAPES = [
      [], // index 0 unused
      [[1,1,1,1],[0,0,0,0],[0,0,0,0],[0,0,0,0]], // I
      [[1,1,0,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]], // O
      [[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // T
      [[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]], // S
      [[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]], // Z
      [[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // J
      [[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]], // L
    ];

    function rotateMatrix(matrix) {
      const n = matrix.length;
      const out = Array(n).fill(0).map(() => Array(n).fill(0));
      for (let r = 0; r < n; r++)
        for (let c = 0; c < n; c++)
          out[c][n - 1 - r] = matrix[r][c];
      return out;
    }

    function getShapeMatrix(shapeId, rotation) {
      let m = SHAPES[shapeId].map(row => [...row]);
      for (let i = 0; i < rotation; i++) m = rotateMatrix(m);
      return m;
    }

    // --- State ---
    let grid;
    let currentPiece;
    let score;
    let gameOver;
    let dropTimer;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const gameOverEl = document.getElementById('game-over');
    const restartBtn = document.getElementById('restart');

    function initGrid() {
      grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
    }

    function reset() {
      initGrid();
      score = 0;
      gameOver = false;
      scoreEl.textContent = 'Score: 0';
      gameOverEl.classList.remove('show');
      spawn();
      draw();
      if (dropTimer) clearInterval(dropTimer);
      dropTimer = setInterval(tick, DROP_MS);
    }

    // --- Collision ---
    function canPlace(piece, px, py) {
      const matrix = getShapeMatrix(piece.shapeId, piece.rotation);
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!matrix[r][c]) continue;
          const nx = px + c;
          const ny = py + r;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return false;
          if (ny >= 0 && grid[ny][nx]) return false;
        }
      }
      return true;
    }

    // --- Spawn ---
    function spawn() {
      const shapeId = 1 + Math.floor(Math.random() * 7);
      currentPiece = {
        shapeId,
        x: SPAWN_X,
        y: SPAWN_Y,
        rotation: 0,
      };
      if (!canPlace(currentPiece, currentPiece.x, currentPiece.y)) {
        gameOver = true;
        gameOverEl.classList.add('show');
        if (dropTimer) clearInterval(dropTimer);
      }
    }

    // --- Lock ---
    function lock() {
      const matrix = getShapeMatrix(currentPiece.shapeId, currentPiece.rotation);
      const color = currentPiece.shapeId;
      for (let r = 0; r < 4; r++) {
        for (let c = 0; c < 4; c++) {
          if (!matrix[r][c]) continue;
          const gy = currentPiece.y + r;
          const gx = currentPiece.x + c;
          if (gy >= 0 && gy < ROWS && gx >= 0 && gx < COLS)
            grid[gy][gx] = color;
        }
      }
      // Clear full rows (from bottom)
      let cleared = 0;
      for (let row = ROWS - 1; row >= 0; row--) {
        if (grid[row].every(cell => cell !== 0)) {
          grid.splice(row, 1);
          grid.unshift(Array(COLS).fill(0));
          cleared++;
          row++;
        }
      }
      if (cleared > 0) {
        score += SCORE_PER_LINE[cleared] || 0;
        scoreEl.textContent = 'Score: ' + score;
      }
      spawn();
    }

    function tick() {
      if (gameOver) return;
      if (canPlace(currentPiece, currentPiece.x, currentPiece.y + 1)) {
        currentPiece.y++;
      } else {
        lock();
      }
      draw();
    }

    // --- Controls ---
    document.addEventListener('keydown', (e) => {
      if (gameOver) return;
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          if (canPlace(currentPiece, currentPiece.x - 1, currentPiece.y))
            currentPiece.x--;
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (canPlace(currentPiece, currentPiece.x + 1, currentPiece.y))
            currentPiece.x++;
          break;
        case 'ArrowDown':
          e.preventDefault();
          if (canPlace(currentPiece, currentPiece.x, currentPiece.y + 1)) {
            currentPiece.y++;
            score += 1;
            scoreEl.textContent = 'Score: ' + score;
          } else {
            lock();
          }
          break;
        case 'ArrowUp':
          e.preventDefault();
          const nextRot = (currentPiece.rotation + 1) % 4;
          const rotated = { ...currentPiece, rotation: nextRot };
          if (canPlace(rotated, currentPiece.x, currentPiece.y))
            currentPiece.rotation = nextRot;
          break;
      }
      draw();
    });

    restartBtn.addEventListener('click', reset);

    // --- Draw ---
    function draw() {
      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const color = grid[row][col];
          ctx.fillStyle = color ? COLORS[color] : '#1a1a2e';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.fillRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeRect(col * BLOCK_SIZE, row * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }

      // Current piece
      if (currentPiece && !gameOver) {
        const matrix = getShapeMatrix(currentPiece.shapeId, currentPiece.rotation);
        ctx.fillStyle = COLORS[currentPiece.shapeId];
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            if (!matrix[r][c]) continue;
            const x = (currentPiece.x + c) * BLOCK_SIZE;
            const y = (currentPiece.y + r) * BLOCK_SIZE;
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = '#333';
            ctx.strokeRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
          }
        }
      }
    }

    // --- Start ---
    reset();
  </script>
</body>
</html>
